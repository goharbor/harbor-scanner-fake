// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for HarborSbomReportMediaType.
const (
	HarborSbomReportMediaTypeApplicationspdxJson         HarborSbomReportMediaType = "application/spdx+json"
	HarborSbomReportMediaTypeApplicationvndCyclonedxJson HarborSbomReportMediaType = "application/vnd.cyclonedx+json"
)

// Defines values for SbomParametersSbomMediaTypes.
const (
	SbomParametersSbomMediaTypesApplicationspdxJson         SbomParametersSbomMediaTypes = "application/spdx+json"
	SbomParametersSbomMediaTypesApplicationvndCyclonedxJson SbomParametersSbomMediaTypes = "application/vnd.cyclonedx+json"
)

// Defines values for ScanRequestEnabledCapabilitiesType.
const (
	ScanRequestEnabledCapabilitiesTypeSbom          ScanRequestEnabledCapabilitiesType = "sbom"
	ScanRequestEnabledCapabilitiesTypeVulnerability ScanRequestEnabledCapabilitiesType = "vulnerability"
)

// Defines values for ScannerCapabilityType.
const (
	ScannerCapabilityTypeSbom          ScannerCapabilityType = "sbom"
	ScannerCapabilityTypeVulnerability ScannerCapabilityType = "vulnerability"
)

// Defines values for Severity.
const (
	Critical   Severity = "Critical"
	High       Severity = "High"
	Low        Severity = "Low"
	Medium     Severity = "Medium"
	Negligible Severity = "Negligible"
	Unknown    Severity = "Unknown"
)

// Artifact defines model for Artifact.
type Artifact struct {
	// Digest The artifact's digest, consisting of an algorithm and hex portion.
	Digest *string `json:"digest,omitempty"`

	// MimeType The MIME type of the artifact.
	MimeType *string `json:"mime_type,omitempty"`

	// Repository The name of the Docker Registry repository containing the artifact.
	Repository *string `json:"repository,omitempty"`

	// Tag The artifact's tag
	Tag *string `json:"tag,omitempty"`
}

// CVSSDetails defines model for CVSSDetails.
type CVSSDetails struct {
	// ScoreV2 The CVSS 2.0 score for the vulnerability.
	ScoreV2 *float32 `json:"score_v2,omitempty"`

	// ScoreV3 The CVSS 3.0 score for the vulnerability.
	ScoreV3 *float32 `json:"score_v3,omitempty"`

	// VectorV2 The CVSS 2.0 vector for the vulnerability. The string is of the form AV:L/AC:M/Au:N/C:P/I:N/A:N
	VectorV2 *string `json:"vector_v2,omitempty"`

	// VectorV3 The CVSS 3.0 vector for the vulnerability.
	VectorV3 *string `json:"vector_v3,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *Error `json:"error,omitempty"`
}

// HarborSbomReport defines model for HarborSbomReport.
type HarborSbomReport struct {
	Artifact *Artifact `json:"artifact,omitempty"`

	// GeneratedAt The time of the report generated.
	GeneratedAt *time.Time `json:"generated_at,omitempty"`

	// MediaType The format of the sbom data.
	MediaType *HarborSbomReportMediaType `json:"media_type,omitempty"`

	// Sbom The raw data of the sbom generated by the scanner.
	Sbom *map[string]interface{} `json:"sbom,omitempty"`

	// Scanner Basic scanner properties such as name, vendor, and version.
	Scanner *Scanner `json:"scanner,omitempty"`

	// VendorAttributes The additional attributes of the vendor.
	VendorAttributes *map[string]interface{} `json:"vendor_attributes,omitempty"`
}

// HarborSbomReportMediaType The format of the sbom data.
type HarborSbomReportMediaType string

// HarborVulnerabilityReport defines model for HarborVulnerabilityReport.
type HarborVulnerabilityReport struct {
	Artifact    *Artifact  `json:"artifact,omitempty"`
	GeneratedAt *time.Time `json:"generated_at,omitempty"`

	// Scanner Basic scanner properties such as name, vendor, and version.
	Scanner *Scanner `json:"scanner,omitempty"`

	// Severity A standard scale for measuring the severity of a vulnerability.
	//
	// * `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
	//   scanner did not recognize.
	// * `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
	//   situation, has almost no install base, or does no real damage.
	// * `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
	//   a small install base, or does very little damage.
	// * `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
	//   service attacks, cross-site scripting, and gaining user privileges.
	// * `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
	//   of service, local root privilege escalations, or data loss.
	// * `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
	//   remote root privilege escalations, or massive data loss.
	Severity        *Severity            `json:"severity,omitempty"`
	Vulnerabilities *[]VulnerabilityItem `json:"vulnerabilities,omitempty"`
}

// Registry defines model for Registry.
type Registry struct {
	// Authorization An optional value of the HTTP Authorization header sent with each request to the Docker Registry v2 API.
	// It's used to exchange Base64 encoded robot account credentials to a short lived JWT access token which
	// allows the underlying scanner to pull the artifact from the Docker Registry.
	Authorization *string `json:"authorization,omitempty"`

	// Url A base URL or the Docker Registry v2 API.
	Url *string `json:"url,omitempty"`
}

// SbomParameters defines model for SbomParameters.
type SbomParameters struct {
	SbomMediaTypes *[]SbomParametersSbomMediaTypes `json:"sbom_media_types,omitempty"`
}

// SbomParametersSbomMediaTypes defines model for SbomParameters.SbomMediaTypes.
type SbomParametersSbomMediaTypes string

// ScanRequest defines model for ScanRequest.
type ScanRequest struct {
	Artifact Artifact `json:"artifact"`

	// EnabledCapabilities Enable which capabilities supported by scanner, for backward compatibility, without this field scanner can be considered to enable all capabilities by default.
	EnabledCapabilities *[]struct {
		// Parameters The additional parameters for the scan request, for the SBOM type, harbor will carry with `sbom_media_types` to specify the expected formats for SBOM content.
		Parameters *ScanRequest_EnabledCapabilities_Parameters `json:"parameters"`

		// ProducesMimeTypes The set of MIME types of reports generated by the scanner for the consumes_mime_types of the same capability record, it is a subset or fullset of the
		// produces_mime_types of the capability returned by the metadata API, used for client to fine grained control of the expected report type. It's a optional
		// field, only applied when client needs to customize it, otherwise the scanner can think it's a fullset as before behavior if without this field.
		ProducesMimeTypes *[]string `json:"produces_mime_types,omitempty"`

		// Type The type of the scan capability.
		Type ScanRequestEnabledCapabilitiesType `json:"type"`
	} `json:"enabled_capabilities,omitempty"`
	Registry Registry `json:"registry"`
}

// ScanRequest_EnabledCapabilities_Parameters The additional parameters for the scan request, for the SBOM type, harbor will carry with `sbom_media_types` to specify the expected formats for SBOM content.
type ScanRequest_EnabledCapabilities_Parameters struct {
	union json.RawMessage
}

// ScanRequestEnabledCapabilitiesType The type of the scan capability.
type ScanRequestEnabledCapabilitiesType string

// ScanRequestId A unique identifier returned by the [/scan](#/operation/AcceptScanRequest] operations. The format of the
// identifier is not imposed but it should be unique enough to prevent collisons when polling for scan reports.
type ScanRequestId = string

// ScanResponse defines model for ScanResponse.
type ScanResponse struct {
	// Id A unique identifier returned by the [/scan](#/operation/AcceptScanRequest] operations. The format of the
	// identifier is not imposed but it should be unique enough to prevent collisons when polling for scan reports.
	Id ScanRequestId `json:"id"`
}

// Scanner Basic scanner properties such as name, vendor, and version.
type Scanner struct {
	// Name The name of the scanner.
	Name *string `json:"name,omitempty"`

	// Vendor The name of the scanner's provider.
	Vendor *string `json:"vendor,omitempty"`

	// Version The version of the scanner.
	Version *string `json:"version,omitempty"`
}

// ScannerAdapterMetadata Represents metadata of a Scanner Adapter which allows Harbor to lookup a scanner capabilities
// of scanning a given Artifact stored in its registry and making sure that it
// can interpret a returned result.
type ScannerAdapterMetadata struct {
	Capabilities []ScannerCapability `json:"capabilities"`

	// Properties A set of custom properties that can further describe capabilities of a given scanner.
	Properties *ScannerProperties `json:"properties,omitempty"`

	// Scanner Basic scanner properties such as name, vendor, and version.
	Scanner Scanner `json:"scanner"`
}

// ScannerCapability Capability consists of the set of recognized artifact MIME types and the set of scanner report MIME types.
//
// For example, a scanner capable of analyzing Docker images and producing a vulnerabilities report recognizable
// by Harbor web console might be represented with the following capability:
// - consumes MIME types:
//   - `application/vnd.oci.image.manifest.v1+json`
//   - `application/vnd.docker.distribution.manifest.v2+json`
//
// - produces MIME types:
//   - `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0`
//
// For example, a scanner capable of analyzing artifacts and producing a sbom report recognizable
// by Harbor might be represented with the following capability:
// - type: sbom
// - consumes MIME types:
//   - `application/vnd.oci.image.manifest.v1+json`
//   - `application/vnd.docker.distribution.manifest.v2+json`
//
// - produces MIME types:
//   - `application/vnd.security.sbom.report+json; version=1.0`
type ScannerCapability struct {
	AdditionalAttributes *map[string]interface{} `json:"additional_attributes,omitempty"`

	// ConsumesMimeTypes The set of MIME types of the artifacts supported by the scanner to produce the reports specified in the "produces_mime_types". A given
	// mime type should only be present in one capability item.
	ConsumesMimeTypes []string `json:"consumes_mime_types"`

	// ProducesMimeTypes The set of MIME types of reports generated by the scanner for the consumes_mime_types of the same capability record.
	ProducesMimeTypes []string `json:"produces_mime_types"`

	// Type The type of the capability, for example, 'vulnerability' represents analyzing the artifact then producing the vulnerabilities report,
	// 'sbom' represents generating the corresponding sbom for the artifact which be scanned. In order to the backward and forward compatible,
	// the field is optional, we think it's a original 'vulnerability' scan if no such field.
	Type *ScannerCapabilityType `json:"type,omitempty"`
}

// ScannerCapabilityType The type of the capability, for example, 'vulnerability' represents analyzing the artifact then producing the vulnerabilities report,
// 'sbom' represents generating the corresponding sbom for the artifact which be scanned. In order to the backward and forward compatible,
// the field is optional, we think it's a original 'vulnerability' scan if no such field.
type ScannerCapabilityType string

// ScannerProperties A set of custom properties that can further describe capabilities of a given scanner.
type ScannerProperties map[string]string

// Severity A standard scale for measuring the severity of a vulnerability.
//
//   - `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
//     scanner did not recognize.
//   - `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
//     situation, has almost no install base, or does no real damage.
//   - `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
//     a small install base, or does very little damage.
//   - `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
//     service attacks, cross-site scripting, and gaining user privileges.
//   - `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
//     of service, local root privilege escalations, or data loss.
//   - `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
//     remote root privilege escalations, or massive data loss.
type Severity string

// VulnerabilityItem defines model for VulnerabilityItem.
type VulnerabilityItem struct {
	// CweIds The Common Weakness Enumeration Identifiers associated with this vulnerability.
	CweIds *[]string `json:"cwe_ids,omitempty"`

	// Description The detailed description of the vulnerability.
	Description *string `json:"description,omitempty"`

	// FixVersion The version of the package containing the fix if available.
	FixVersion *string `json:"fix_version,omitempty"`

	// Id The unique identifier of the vulnerability.
	Id *string `json:"id,omitempty"`

	// Links The list of links to the upstream databases with the full description of the vulnerability.
	Links *[]string `json:"links,omitempty"`

	// Package An operating system package containing the vulnerability.
	Package       *string      `json:"package,omitempty"`
	PreferredCvss *CVSSDetails `json:"preferred_cvss,omitempty"`

	// Severity A standard scale for measuring the severity of a vulnerability.
	//
	// * `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
	//   scanner did not recognize.
	// * `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
	//   situation, has almost no install base, or does no real damage.
	// * `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
	//   a small install base, or does very little damage.
	// * `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
	//   service attacks, cross-site scripting, and gaining user privileges.
	// * `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
	//   of service, local root privilege escalations, or data loss.
	// * `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
	//   remote root privilege escalations, or massive data loss.
	Severity         *Severity               `json:"severity,omitempty"`
	VendorAttributes *map[string]interface{} `json:"vendor_attributes,omitempty"`

	// Version The version of the package containing the vulnerability.
	Version *string `json:"version,omitempty"`
}

// GetScanReportParams defines parameters for GetScanReport.
type GetScanReportParams struct {
	// SbomMediaType media_type specifies the format of SBOM to be retrieved from the scanner adapter, it should either SPDX SBOM or CycloneDX
	SbomMediaType *string `form:"sbom_media_type,omitempty" json:"sbom_media_type,omitempty"`
	Accept        *string `json:"Accept,omitempty"`
}

// AcceptScanRequestApplicationVndScannerAdapterScanRequestPlusJSONVersion10RequestBody defines body for AcceptScanRequest for application/vnd.scanner.adapter.scan.request+json; version=1.0 ContentType.
type AcceptScanRequestApplicationVndScannerAdapterScanRequestPlusJSONVersion10RequestBody = ScanRequest

// AcceptScanRequestApplicationVndScannerAdapterScanRequestPlusJSONVersion11RequestBody defines body for AcceptScanRequest for application/vnd.scanner.adapter.scan.request+json; version=1.1 ContentType.
type AcceptScanRequestApplicationVndScannerAdapterScanRequestPlusJSONVersion11RequestBody = ScanRequest

// AsSbomParameters returns the union data inside the ScanRequest_EnabledCapabilities_Parameters as a SbomParameters
func (t ScanRequest_EnabledCapabilities_Parameters) AsSbomParameters() (SbomParameters, error) {
	var body SbomParameters
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSbomParameters overwrites any union data inside the ScanRequest_EnabledCapabilities_Parameters as the provided SbomParameters
func (t *ScanRequest_EnabledCapabilities_Parameters) FromSbomParameters(v SbomParameters) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSbomParameters performs a merge with any union data inside the ScanRequest_EnabledCapabilities_Parameters, using the provided SbomParameters
func (t *ScanRequest_EnabledCapabilities_Parameters) MergeSbomParameters(v SbomParameters) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScanRequest_EnabledCapabilities_Parameters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScanRequest_EnabledCapabilities_Parameters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get scanner metadata
	// (GET /metadata)
	GetMetadata(ctx echo.Context) error
	// Accept artifact scanning request
	// (POST /scan)
	AcceptScanRequest(ctx echo.Context) error
	// Get scan report
	// (GET /scan/{scan_request_id}/report)
	GetScanReport(ctx echo.Context, scanRequestId ScanRequestId, params GetScanReportParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetadata(ctx)
	return err
}

// AcceptScanRequest converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptScanRequest(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AcceptScanRequest(ctx)
	return err
}

// GetScanReport converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanReport(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scan_request_id" -------------
	var scanRequestId ScanRequestId

	err = runtime.BindStyledParameterWithOptions("simple", "scan_request_id", ctx.Param("scan_request_id"), &scanRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scan_request_id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanReportParams
	// ------------- Optional query parameter "sbom_media_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sbom_media_type", ctx.QueryParams(), &params.SbomMediaType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sbom_media_type: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanReport(ctx, scanRequestId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/metadata", wrapper.GetMetadata)
	router.POST(baseURL+"/scan", wrapper.AcceptScanRequest)
	router.GET(baseURL+"/scan/:scan_request_id/report", wrapper.GetScanReport)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
